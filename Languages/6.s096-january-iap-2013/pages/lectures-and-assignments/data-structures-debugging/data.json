
{
  "title":"Data Structures, Debugging",
  "content":"Topics: Using structs, unions, typedef, and enums, and how to debug with Valgrind and GDB.\nLecture Notes Lecture 4: Data Structures, Debugging (PDF)\nLab Exercises The primary goal of this lab period is to introduce debugging tools, and use of unions/structs.\nExercise 1 Download and install Valgrind on your system, if it\u0026rsquo;s not already. To test if you have Valgrind, run valgrind --version. It should print the version of Valgrind that is installed.\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; void fn() { int* x = malloc(10 * sizeof(int)); printf(\u0026#34;%d\u0026#34;,*x); x[10] = 0; } int main() { fn(); return 0; } There are 3 sources of memory errors in this code. Run valgrind to determine what they are (although I suspect you can probably tell from the code anyways).\nExercise 2 Use a union to print the individual bytes of an int. (Hint: Recall the size of ints and other data types.)\nExercise 3 Determine how much memory is required for each of the structs below. How much of that memory is padding between the members?\nstruct X { short s; int i; char c; }; struct Y { int i; char c; short s; }; struct Z { int i; short s; char c; }; Assignment 4 Today\u0026rsquo;s assignment combines the material from the past few lectures. Your job is to fill in the skeleton code we provide. I have commented the code with what each section should do.\nAssignment 4 files (ZIP) (This ZIP file conatins: 2 .c files and 1 .h file.)\nYou can learn more about binary search trees and find pseudo-code on the binary search tree page on Wikipedia.\nYour job is to implement a binary search tree, a data structure of connected nodes with a tree shape. Each node has a node identifier (a number), data (payload), and 2 children (left and right). The children are other nodes referenced with a pointer, with the constraint that the left node\u0026rsquo;s ID is less than the parent node\u0026rsquo;s ID, and the right node\u0026rsquo;s ID is larger than the parent node ID. No two nodes will have the same identifier. A node can have less than two children; in that case, one or more of its child pointers can be NULL.\nImage by MIT OpenCourseWare.\nuser.c contains the main() function. We will replace this function with one for grading. You should use your main() function to test that your functions to insert into and search the binary tree work correctly.\nThis is a C/C++ course, not an algorithms course, but if you want a challenge, try implementing node deletion as well!\nYour job is to complete the data structure and function declarations in bintree.h, then complete the implementation of your functions in bintree.c. If you want to define additional functions to simplify your program, that\u0026rsquo;s fine. You cannot change the return types or argument types of the included functions, though. Even though we don\u0026rsquo;t require the deletion function, make sure to free all memory you allocate!\nMake sure your program compiles without warning, runs, and definitely use valgrind to ensure you have no memory leaks.\n$ gcc -Wall -std=c99 user.c bintree.c -o bintree $ ./bintree \u0026lt;your test output\u0026gt; Solutions Solutions are not available for this assignment.\n"}


